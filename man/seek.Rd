% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seek.R
\name{seek}
\alias{seek}
\alias{seek_in}
\alias{process_files_lines}
\title{Extract Matching Lines from Matching Files}
\usage{
seek(
  pattern,
  path = ".",
  filter = NULL,
  recursive = FALSE,
  all.files = FALSE,
  n = -1L,
  warn = FALSE,
  relative_path = TRUE
)

seek_in(pattern, files, n = -1L, warn = FALSE)

process_files_lines(files, pattern, warn, n, relative_path)
}
\arguments{
\item{pattern}{A string. A Perl-compatible regular expression used to filter
the lines of the files.}

\item{path}{a character vector of full path names; the default
    corresponds to the working directory, \code{\link[base]{getwd}()}.  Tilde
    expansion (see \code{\link[base]{path.expand}}) is performed.  Missing
    values will be ignored.  Elements with a marked encoding will
    be converted to the native encoding (and if that fails, considered
    non-existent).}

\item{filter}{Optional. A Perl-compatible regular expression used to filter
file names before reading them. If \code{NULL}, all files are considered.}

\item{recursive}{logical.  Should the listing recurse into directories?}

\item{all.files}{a logical value.  If \code{FALSE}, only the
    names of visible files are returned (following Unix-style visibility,
    that is files whose name does not start with a dot).  If \code{TRUE},
    all file names will be returned.}

\item{n}{integer.  The (maximal) number of lines to
    read.  Negative values indicate that one should read up to the end of
    input on the connection.}

\item{warn}{logical.  Warn if a text file is missing a final \abbr{EOL} or if
    there are embedded \abbr{NUL}s in the file.}

\item{relative_path}{Logical. If \code{TRUE}, returned paths are made relative to
the \code{path} argument. Only applies to \code{seek()}.}

\item{files}{A character vector of file paths to be used directly, instead of searching
a directory. Only used in \code{seek_in()}.}
}
\value{
A tibble with one row per matching line, containing:
\itemize{
\item \code{file}: Integer index of the file in the list.
\item \code{path}: Path to the file.
\item \code{line}: Line number within the file.
\item \code{match}: The first matched substring.
\item \code{matches}: All matched substrings.
\item \code{content}: Content of the matching line.
}
}
\description{
Searches for lines matching a regular expression pattern in a set of files.
In \code{seek()}, the files are discovered within a directory (recursively or not),
and optionally filtered using a path pattern. In \code{seek_in()}, the files
are provided directly by the user.
}
\details{
These functions combine file listing (or direct input), filtering, reading,
and pattern extraction into a single interface. They are especially useful
for searching through codebases, configuration files, or logs.

The search is case-sensitive and uses Perl-compatible regular expressions (PCRE).
}
\examples{
\dontrun{
# Find all function definitions in R files under current directory
seek("[^\\\\s]+(?= = function\\\\()", filter = "\\\\.R$", recursive = TRUE)

# Find all package loaded using `library() in a predefined list of files
files = list.files(pattern = "\\\\.R$", recursive = TRUE)
seek_in("(?<=library\\\\()[^\\\\)]+", files)
}

}
\concept{seek}
\keyword{internal}
