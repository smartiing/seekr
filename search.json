[{"path":"https://smartiing.github.io/seekr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 seekr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://smartiing.github.io/seekr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sacha Martingay. Author, maintainer, copyright holder.","code":""},{"path":"https://smartiing.github.io/seekr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martingay S (2025). seekr: Extract Matching Lines Matching Files. R package version 0.1.0, https://github.com/smartiing/seekr.","code":"@Manual{,   title = {seekr: Extract Matching Lines from Matching Files},   author = {Sacha Martingay},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/smartiing/seekr}, }"},{"path":[]},{"path":"https://smartiing.github.io/seekr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Extract Matching Lines from Matching Files","text":"seekr R package designed help search specific patterns within text files.","code":""},{"path":"https://smartiing.github.io/seekr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Extract Matching Lines from Matching Files","text":"","code":"# Install it directly from CRAN: install.packages(\"seekr\")  # Or the the development version from GitHub: # install.packages(\"pak\") pak::pak(\"smartiing/seekr\")"},{"path":"https://smartiing.github.io/seekr/index.html","id":"functions","dir":"","previous_headings":"","what":"Functions","title":"Extract Matching Lines from Matching Files","text":"seekr provides two main functions: seek(): Search pattern files within specified directory. seek_in(): Search pattern given list files. function returns tibble following columns: path: Path file (relative absolute). line_number: Line number pattern found. match: first match found line. matches: matches found line (matches = TRUE). line: Content matching line.","code":""},{"path":"https://smartiing.github.io/seekr/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Extract Matching Lines from Matching Files","text":"","code":"library(seekr) #>  #> Attaching package: 'seekr' #> The following object is masked from 'package:base': #>  #>     seek  path = system.file(\"extdata\", package = \"seekr\")  # Search all function definitions in R files seek(\"[^\\\\s]+(?= (=|<-) function\\\\()\", path, filter = \"\\\\.R$\") #> # A tibble: 6 × 4 #>   path       line_number match        line                          #>   <fs::path>       <int> <chr>        <chr>                         #> 1 /script1.R           1 add_one      add_one <- function(x) {      #> 2 /script1.R           5 capitalize   capitalize <- function(txt) { #> 3 /script1.R           9 say_hello    say_hello <- function(name) { #> 4 /script2.R           2 mean_safe    mean_safe <- function(x) {    #> 5 /script2.R           7 sd_safe      sd_safe <- function(x) {      #> 6 /script2.R          12 print_vector print_vector <- function(v) {  # Search for usage of \"TODO\" comments in source code in a case insensitive way seek(\"(?i)TODO\", path, filter = \"\\\\.R$\") #> # A tibble: 1 × 4 #>   path       line_number match line                           #>   <fs::path>       <int> <chr> <chr>                          #> 1 /script2.R           1 TODO  # TODO: optimize this function  # Search for error/warning in log files seek(\"(?i)error\", path, filter = \"\\\\.log$\") #> # A tibble: 14 × 4 #>    path        line_number match line                                            #>    <fs::path>        <int> <chr> <chr>                                           #>  1 /server.log           3 ERROR 2025-04-29 21:52:17 ERROR : Starting process    #>  2 /server.log           6 ERROR 2025-04-30 04:15:43 ERROR : Retrying request    #>  3 /server.log           7 ERROR 2025-04-29 13:59:14 ERROR : Failed to authenti… #>  4 /server.log          10 ERROR 2025-04-30 17:20:48 ERROR : User login failed   #>  5 /server.log          11 ERROR 2025-04-30 11:41:17 ERROR : Starting process    #>  6 /server.log          14 ERROR 2025-04-30 00:15:59 ERROR : Connection success… #>  7 /server.log          16 ERROR 2025-04-29 20:39:24 ERROR : User login failed   #>  8 /server.log          19 ERROR 2025-04-29 17:51:14 ERROR : Timeout reached     #>  9 /server.log          20 ERROR 2025-04-29 18:27:07 ERROR : Retrying request    #> 10 /server.log          21 ERROR 2025-04-30 16:15:44 ERROR : Disk usage high     #> 11 /server.log          23 ERROR 2025-04-30 17:14:15 ERROR : User login failed   #> 12 /server.log          30 ERROR 2025-04-30 00:03:39 ERROR : Connection success… #> 13 /server.log          35 ERROR 2025-04-30 17:25:05 ERROR : Connection success… #> 14 /server.log          40 ERROR 2025-04-29 17:49:55 ERROR : Restart scheduled  # Search for config keys in YAML seek(\"database:\", path, filter = \"\\\\.ya?ml$\") #> # A tibble: 1 × 4 #>   path         line_number match     line      #>   <fs::path>         <int> <chr>     <chr>     #> 1 /config.yaml           1 database: database:  # Looking for \"length\" in all types of text files seek(\"(?i)length\", path) #> # A tibble: 4 × 4 #>   path       line_number match  line                                             #>   <fs::path>       <int> <chr>  <chr>                                            #> 1 /iris.csv            1 Length \"\\\"Sepal.Length\\\",\\\"Sepal.Width\\\",\\\"Petal.Lengt… #> 2 /script2.R           3 length \"  if (length(x) == 0) return(NA)\"               #> 3 /script2.R           8 length \"  if (length(x) <= 1) return(NA)\"               #> 4 /script2.R          13 length \"  print(paste('Vector of length', length(v)))\"  # Search for specific CSV headers using seek_in() and reading only the first line csv_files <- list.files(path, \"\\\\.csv$\", full.names = TRUE) seek_in(csv_files, \"(?i)specie\", n_max = 1) #> # A tibble: 1 × 4 #>   path                                                   line_number match line  #>   <fs::path>                                                   <int> <chr> <chr> #> 1 …YzN7t/temp_libpath4cf462766a0b/seekr/extdata/iris.csv           1 Spec… \"\\\"S…"},{"path":"https://smartiing.github.io/seekr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Extract Matching Lines from Matching Files","text":"package licensed MIT License.","code":""},{"path":"https://smartiing.github.io/seekr/reference/assert_flag_or_scalar_integerish.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert Flag or Scalar Integerish — assert_flag_or_scalar_integerish","title":"Assert Flag or Scalar Integerish — assert_flag_or_scalar_integerish","text":"Assertion function check_flag_or_scalar_integerish(). throw error input invalid.","code":""},{"path":"https://smartiing.github.io/seekr/reference/assert_flag_or_scalar_integerish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert Flag or Scalar Integerish — assert_flag_or_scalar_integerish","text":"","code":"assert_flag_or_scalar_integerish(   x,   .var.name = checkmate::vname(x),   add = NULL )"},{"path":"https://smartiing.github.io/seekr/reference/assert_flag_or_scalar_integerish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert Flag or Scalar Integerish — assert_flag_or_scalar_integerish","text":"x object check.","code":""},{"path":"https://smartiing.github.io/seekr/reference/check_flag_or_scalar_integerish.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Flag or Scalar Integerish — check_flag_or_scalar_integerish","title":"Check Flag or Scalar Integerish — check_flag_or_scalar_integerish","text":"function validates whether input either logical flag (TRUE/FALSE) scalar integer-like value (e.g., 1, 2L, etc.).","code":""},{"path":"https://smartiing.github.io/seekr/reference/check_flag_or_scalar_integerish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Flag or Scalar Integerish — check_flag_or_scalar_integerish","text":"","code":"check_flag_or_scalar_integerish(x)"},{"path":"https://smartiing.github.io/seekr/reference/check_flag_or_scalar_integerish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Flag or Scalar Integerish — check_flag_or_scalar_integerish","text":"x object check.","code":""},{"path":"https://smartiing.github.io/seekr/reference/check_flag_or_scalar_integerish.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Flag or Scalar Integerish — check_flag_or_scalar_integerish","text":"TRUE input valid flag scalar integerish, otherwise error message string.","code":""},{"path":"https://smartiing.github.io/seekr/reference/extract_lower_file_extension.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Lowercase File Extensions — extract_lower_file_extension","title":"Extract Lowercase File Extensions — extract_lower_file_extension","text":"Extracts file extensions provided file paths, normalizes lowercase, returns character vector. extension includes leading period (.).","code":""},{"path":"https://smartiing.github.io/seekr/reference/extract_lower_file_extension.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Lowercase File Extensions — extract_lower_file_extension","text":"","code":"extract_lower_file_extension(files)"},{"path":"https://smartiing.github.io/seekr/reference/extract_lower_file_extension.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Lowercase File Extensions — extract_lower_file_extension","text":"files character vector files search (seek_in()).","code":""},{"path":"https://smartiing.github.io/seekr/reference/extract_lower_file_extension.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Lowercase File Extensions — extract_lower_file_extension","text":"character vector lowercase file extensions.","code":""},{"path":"https://smartiing.github.io/seekr/reference/filter_files.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter Files by Pattern and Content Type — filter_files","title":"Filter Files by Pattern and Content Type — filter_files","text":"Filters character vector file paths using user-defined pattern additional content-based criteria ensure likely text files retained. function applies multiple filters: regex-based path filter (provided). Exclusion files located within .git folders. Exclusion files known binary non-text extensions. fallback scan embedded null bytes detect binary content ambiguous files. function returns filtered character vector file paths likely valid text files.","code":""},{"path":"https://smartiing.github.io/seekr/reference/filter_files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter Files by Pattern and Content Type — filter_files","text":"","code":"filter_files(files, filter, negate, n = 1000L)"},{"path":"https://smartiing.github.io/seekr/reference/filter_files.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter Files by Pattern and Content Type — filter_files","text":"files character vector files search (seek_in()). filter Optional. regular expression pattern used filter file paths reading. NULL, text files considered. negate Logical. TRUE, files matching filter pattern excluded instead included. Useful skip files based name extension. n number bytes read binary detection files unknown extensions. Defaults 1000.","code":""},{"path":"https://smartiing.github.io/seekr/reference/filter_files.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter Files by Pattern and Content Type — filter_files","text":"character vector file paths identified potential text files. matching files found, informative error thrown.","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_known_nontext_extension.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify Files with Known Non-Text Extensions — has_known_nontext_extension","title":"Identify Files with Known Non-Text Extensions — has_known_nontext_extension","text":"Checks whether provided file paths extensions typically associated binary non-text formats (e.g., images, archives, executables).","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_known_nontext_extension.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify Files with Known Non-Text Extensions — has_known_nontext_extension","text":"","code":"has_known_nontext_extension(files)"},{"path":"https://smartiing.github.io/seekr/reference/has_known_nontext_extension.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify Files with Known Non-Text Extensions — has_known_nontext_extension","text":"files character vector files search (seek_in()).","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_known_nontext_extension.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify Files with Known Non-Text Extensions — has_known_nontext_extension","text":"logical vector indicating whether file known non-text extension.","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_known_text_extension.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify Files with Known Text Extensions — has_known_text_extension","title":"Identify Files with Known Text Extensions — has_known_text_extension","text":"Checks whether provided file paths extensions commonly associated text-based formats (e.g., scripts, markdown, configuration files).","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_known_text_extension.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify Files with Known Text Extensions — has_known_text_extension","text":"","code":"has_known_text_extension(files)"},{"path":"https://smartiing.github.io/seekr/reference/has_known_text_extension.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify Files with Known Text Extensions — has_known_text_extension","text":"files character vector files search (seek_in()).","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_known_text_extension.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify Files with Known Text Extensions — has_known_text_extension","text":"logical vector indicating whether file known text extension.","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_null_bytes.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Null Bytes in a File — has_null_bytes","title":"Detect Null Bytes in a File — has_null_bytes","text":"Reads first n bytes file checks whether null bytes (0x00) present, commonly used detect binary files. file read (e.g., corrupted permission issues), function safely assumes file binary returns TRUE.","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_null_bytes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Null Bytes in a File — has_null_bytes","text":"","code":"has_null_bytes(file, n = 1000L)"},{"path":"https://smartiing.github.io/seekr/reference/has_null_bytes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Null Bytes in a File — has_null_bytes","text":"file character string representing single file path. n number bytes read binary detection files unknown extensions. Defaults 1000.","code":""},{"path":"https://smartiing.github.io/seekr/reference/has_null_bytes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Null Bytes in a File — has_null_bytes","text":"TRUE null byte found error occurs. FALSE otherwise.","code":""},{"path":"https://smartiing.github.io/seekr/reference/is_in_gitfolder.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if Files Are Located in a .git Folder — is_in_gitfolder","title":"Check if Files Are Located in a .git Folder — is_in_gitfolder","text":"Identifies whether provided file paths located inside .git directory. function assumes file paths normalized beforehand (.e., using forward slashes / even Windows systems).","code":""},{"path":"https://smartiing.github.io/seekr/reference/is_in_gitfolder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if Files Are Located in a .git Folder — is_in_gitfolder","text":"","code":"is_in_gitfolder(files)"},{"path":"https://smartiing.github.io/seekr/reference/is_in_gitfolder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if Files Are Located in a .git Folder — is_in_gitfolder","text":"files character vector files search (seek_in()).","code":""},{"path":"https://smartiing.github.io/seekr/reference/is_in_gitfolder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if Files Are Located in a .git Folder — is_in_gitfolder","text":"logical vector indicating whether file located within .git folder.","code":""},{"path":"https://smartiing.github.io/seekr/reference/list_files.html","id":null,"dir":"Reference","previous_headings":"","what":"List Files in Directory — list_files","title":"List Files in Directory — list_files","text":"Lists files given directory support recursive search inclusion hidden files. function throws specific error files found, based combination recurse parameters. Returned file paths made unique assumed normalized using forward slashes (/).","code":""},{"path":"https://smartiing.github.io/seekr/reference/list_files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List Files in Directory — list_files","text":"","code":"list_files(path, recurse, all)"},{"path":"https://smartiing.github.io/seekr/reference/list_files.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List Files in Directory — list_files","text":"path character vector one paths. recurse TRUE recurse fully, positive number number levels recurse. TRUE hidden files also returned.","code":""},{"path":"https://smartiing.github.io/seekr/reference/list_files.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List Files in Directory — list_files","text":"character vector unique file paths. files found, function aborts message suggesting adjust search parameters (recurse ), includes class-specific error identifier depending search mode: \"error_list_files_TT\" recurse = TRUE, = TRUE \"error_list_files_TF\" recurse = TRUE, = FALSE \"error_list_files_FT\" recurse = FALSE, = TRUE \"error_list_files_FF\" recurse = FALSE, = FALSE","code":""},{"path":"https://smartiing.github.io/seekr/reference/list_files.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List Files in Directory — list_files","text":"","code":"if (FALSE) { # \\dontrun{ list_files(\"myfolder\", recurse = TRUE, all = FALSE) } # }"},{"path":"https://smartiing.github.io/seekr/reference/prepare_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Tidy Data Frame from Matched Lines — prepare_df","title":"Prepare Tidy Data Frame from Matched Lines — prepare_df","text":"Constructs tidy data frame matched lines across set files. function takes output read_filter_lines() returns one row per match, including file path, line number, full line content, regex match(es).","code":""},{"path":"https://smartiing.github.io/seekr/reference/prepare_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Tidy Data Frame from Matched Lines — prepare_df","text":"","code":"prepare_df(files, pattern, lines, path, relative_path, matches)"},{"path":"https://smartiing.github.io/seekr/reference/prepare_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Tidy Data Frame from Matched Lines — prepare_df","text":"files character vector files search (seek_in()). pattern regular expression pattern used match lines. lines list line_number line, returned read_filter_lines(). path character vector one directories files discovered (seek()). relative_path Logical. TRUE, file paths made relative path argument. multiple root paths provided, relative_path automatically ignored absolute paths kept avoid ambiguity. matches Logical. TRUE, matches per line also returned matches list-column.","code":""},{"path":"https://smartiing.github.io/seekr/reference/prepare_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Tidy Data Frame from Matched Lines — prepare_df","text":"tibble following columns: path: File path (relative specified), marked class fs_path. line_number: Line number match within file. match: first matched substring line. matches (optional): matched substrings list-column. line: Full content matching line.","code":""},{"path":"https://smartiing.github.io/seekr/reference/prepare_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare Tidy Data Frame from Matched Lines — prepare_df","text":"steps executed sequentially transform file-based pattern matches structured tabular format. function assumes input files corresponding line data correctly aligned. handles path normalization, match extraction, output column selection according matches relative_path arguments.","code":""},{"path":"https://smartiing.github.io/seekr/reference/print_cli.html","id":null,"dir":"Reference","previous_headings":"","what":"Should CLI Output Be Printed? — print_cli","title":"Should CLI Output Be Printed? — print_cli","text":"Determines whether CLI progress messaging functions executed. helper evaluates seekr.verbose option, checks interactive session, disables output testthat tests.","code":""},{"path":"https://smartiing.github.io/seekr/reference/print_cli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Should CLI Output Be Printed? — print_cli","text":"","code":"print_cli()"},{"path":"https://smartiing.github.io/seekr/reference/print_cli.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Should CLI Output Be Printed? — print_cli","text":"logical scalar: TRUE CLI output shown, FALSE otherwise.","code":""},{"path":"https://smartiing.github.io/seekr/reference/print_cli.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Should CLI Output Be Printed? — print_cli","text":"function designed control conditional CLI output (e.g., cli::cli_progress_step()). returns TRUE : getOption(\"seekr.verbose\", TRUE) TRUE session interactive (interactive()) testthat running (!testthat::is_testing())","code":""},{"path":"https://smartiing.github.io/seekr/reference/read_filter_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Read and Filter Matching Lines in Text Files — read_filter_lines","title":"Read and Filter Matching Lines in Text Files — read_filter_lines","text":"Reads lines set text files returns lines match specified regular expression pattern. function processes file one--one maintain memory efficiency, making suitable reading large files. Files read (due warnings errors) skipped warning. verbosity enabled via seekr.verbose = TRUE session interactive, function reports progress.","code":""},{"path":"https://smartiing.github.io/seekr/reference/read_filter_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read and Filter Matching Lines in Text Files — read_filter_lines","text":"","code":"read_filter_lines(files, pattern, ...)"},{"path":"https://smartiing.github.io/seekr/reference/read_filter_lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read and Filter Matching Lines in Text Files — read_filter_lines","text":"files character vector files search (seek_in()). pattern regular expression pattern used match lines. ... Additional arguments passed readr::read_lines(), skip, n_max, locale.","code":""},{"path":"https://smartiing.github.io/seekr/reference/read_filter_lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read and Filter Matching Lines in Text Files — read_filter_lines","text":"list two elements: line_number list integer vectors giving line numbers matching lines, one per file. line list character vectors containing matched lines, one per file.","code":""},{"path":"https://smartiing.github.io/seekr/reference/read_filter_lines.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read and Filter Matching Lines in Text Files — read_filter_lines","text":"Files processed sequentially minimize memory usage, especially working large files. lines matching pattern retained file. file raises warning error reading, silently skipped contributes empty entry result lists.","code":""},{"path":"https://smartiing.github.io/seekr/reference/seek.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Matching Lines from Files — seek","title":"Extract Matching Lines from Files — seek","text":"functions search one text files, extract lines matching regular expression pattern, return tibble containing results. seek(): Discovers files inside one directories (recursively ), applies optional file name text file filtering, searches lines. seek_in(): Searches inside user-provided character vector files.","code":""},{"path":"https://smartiing.github.io/seekr/reference/seek.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Matching Lines from Files — seek","text":"","code":"seek(   pattern,   path = \".\",   ...,   filter = NULL,   negate = FALSE,   recurse = FALSE,   all = FALSE,   relative_path = TRUE,   matches = FALSE )  seek_in(files, pattern, ..., matches = FALSE)"},{"path":"https://smartiing.github.io/seekr/reference/seek.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Matching Lines from Files — seek","text":"pattern regular expression pattern used match lines. path character vector one directories files discovered (seek()). ... Additional arguments passed readr::read_lines(), skip, n_max, locale. filter Optional. regular expression pattern used filter file paths reading. NULL, text files considered. negate Logical. TRUE, files matching filter pattern excluded instead included. Useful skip files based name extension. recurse TRUE recurse fully, positive number number levels recurse. TRUE hidden files also returned. relative_path Logical. TRUE, file paths made relative path argument. multiple root paths provided, relative_path automatically ignored absolute paths kept avoid ambiguity. matches Logical. TRUE, matches per line also returned matches list-column. files character vector files search (seek_in()).","code":""},{"path":"https://smartiing.github.io/seekr/reference/seek.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Matching Lines from Files — seek","text":"tibble one row per matched line, containing: path: File path (relative absolute). line_number: Line number file. match: first matched substring. matches: matched substrings (matches = TRUE). line: Full content matching line.","code":""},{"path":"https://smartiing.github.io/seekr/reference/seek.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Matching Lines from Files — seek","text":"overall process involves following steps: File Selection seek(): Files discovered using fs::dir_ls(), starting one directories. seek_in(): Files directly supplied user (discovery phase). File Filtering Files located inside .git/ folders automatically excluded. Files known non-text extensions (e.g., .png, .exe, .rds) excluded. file's extension unknown, check performed detect embedded null bytes (binary indicator). Optionally, additional regex-based path filter (filter) can applied. Line Reading Files read line--line using readr::read_lines(). lines matching provided regular expression pattern retained. file read, skipped gracefully without failing process. Data Frame Construction tibble constructed one row per matched line. functions particularly useful analyzing source code, configuration files, logs, structured text data.","code":""},{"path":[]},{"path":"https://smartiing.github.io/seekr/reference/seek.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Matching Lines from Files — seek","text":"","code":"path = system.file(\"extdata\", package = \"seekr\")  # Search all function definitions in R files seek(\"[^\\\\s]+(?= (=|<-) function\\\\()\", path, filter = \"\\\\.R$\") #> # A tibble: 6 × 4 #>   path       line_number match        line                          #>   <fs::path>       <int> <chr>        <chr>                         #> 1 /script1.R           1 add_one      add_one <- function(x) {      #> 2 /script1.R           5 capitalize   capitalize <- function(txt) { #> 3 /script1.R           9 say_hello    say_hello <- function(name) { #> 4 /script2.R           2 mean_safe    mean_safe <- function(x) {    #> 5 /script2.R           7 sd_safe      sd_safe <- function(x) {      #> 6 /script2.R          12 print_vector print_vector <- function(v) {  # Search for usage of \"TODO\" comments in source code in a case insensitive way seek(\"(?i)TODO\", path, filter = \"\\\\.R$\") #> # A tibble: 1 × 4 #>   path       line_number match line                           #>   <fs::path>       <int> <chr> <chr>                          #> 1 /script2.R           1 TODO  # TODO: optimize this function  # Search for error/warning in log files seek(\"(?i)error\", path, filter = \"\\\\.log$\") #> # A tibble: 14 × 4 #>    path        line_number match line                                            #>    <fs::path>        <int> <chr> <chr>                                           #>  1 /server.log           3 ERROR 2025-04-29 21:52:17 ERROR : Starting process    #>  2 /server.log           6 ERROR 2025-04-30 04:15:43 ERROR : Retrying request    #>  3 /server.log           7 ERROR 2025-04-29 13:59:14 ERROR : Failed to authenti… #>  4 /server.log          10 ERROR 2025-04-30 17:20:48 ERROR : User login failed   #>  5 /server.log          11 ERROR 2025-04-30 11:41:17 ERROR : Starting process    #>  6 /server.log          14 ERROR 2025-04-30 00:15:59 ERROR : Connection success… #>  7 /server.log          16 ERROR 2025-04-29 20:39:24 ERROR : User login failed   #>  8 /server.log          19 ERROR 2025-04-29 17:51:14 ERROR : Timeout reached     #>  9 /server.log          20 ERROR 2025-04-29 18:27:07 ERROR : Retrying request    #> 10 /server.log          21 ERROR 2025-04-30 16:15:44 ERROR : Disk usage high     #> 11 /server.log          23 ERROR 2025-04-30 17:14:15 ERROR : User login failed   #> 12 /server.log          30 ERROR 2025-04-30 00:03:39 ERROR : Connection success… #> 13 /server.log          35 ERROR 2025-04-30 17:25:05 ERROR : Connection success… #> 14 /server.log          40 ERROR 2025-04-29 17:49:55 ERROR : Restart scheduled    # Search for config keys in YAML seek(\"database:\", path, filter = \"\\\\.ya?ml$\") #> # A tibble: 1 × 4 #>   path         line_number match     line      #>   <fs::path>         <int> <chr>     <chr>     #> 1 /config.yaml           1 database: database:  # Looking for \"length\" in all types of text files seek(\"(?i)length\", path) #> # A tibble: 4 × 4 #>   path       line_number match  line                                             #>   <fs::path>       <int> <chr>  <chr>                                            #> 1 /iris.csv            1 Length \"\\\"Sepal.Length\\\",\\\"Sepal.Width\\\",\\\"Petal.Lengt… #> 2 /script2.R           3 length \"  if (length(x) == 0) return(NA)\"               #> 3 /script2.R           8 length \"  if (length(x) <= 1) return(NA)\"               #> 4 /script2.R          13 length \"  print(paste('Vector of length', length(v)))\"   # Search for specific CSV headers using seek_in() and reading only the first line csv_files <- list.files(path, \"\\\\.csv$\", full.names = TRUE) seek_in(csv_files, \"(?i)specie\", n_max = 1) #> # A tibble: 1 × 4 #>   path                                                   line_number match line  #>   <fs::path>                                                   <int> <chr> <chr> #> 1 /home/runner/work/_temp/Library/seekr/extdata/iris.csv           1 Spec… \"\\\"S…"},{"path":"https://smartiing.github.io/seekr/reference/seek_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Read and Prepare Matching Lines — seek_lines","title":"Read and Prepare Matching Lines — seek_lines","text":"Reads set files, filters lines based regular expression pattern, constructs tidy tibble results.","code":""},{"path":"https://smartiing.github.io/seekr/reference/seek_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read and Prepare Matching Lines — seek_lines","text":"","code":"seek_lines(files, pattern, ..., path, relative_path, matches)"},{"path":"https://smartiing.github.io/seekr/reference/seek_lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read and Prepare Matching Lines — seek_lines","text":"files character vector files search (seek_in()). pattern regular expression pattern used match lines. ... Additional arguments passed readr::read_lines(), skip, n_max, locale. path character vector one directories files discovered (seek()). relative_path Logical. TRUE, file paths made relative path argument. multiple root paths provided, relative_path automatically ignored absolute paths kept avoid ambiguity. matches Logical. TRUE, matches per line also returned matches list-column.","code":""},{"path":"https://smartiing.github.io/seekr/reference/seek_lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read and Prepare Matching Lines — seek_lines","text":"tibble one row per matching line.","code":""},{"path":"https://smartiing.github.io/seekr/reference/seekr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"seekr: Extract Matching Lines from Matching Files — seekr-package","title":"seekr: Extract Matching Lines from Matching Files — seekr-package","text":"Provides simple interface recursively list files directory, filter using regular expression, read contents, extract lines match user-defined pattern. package returns dataframe containing matched lines, line numbers, file paths, corresponding matched substrings. Designed quick code base exploration, log inspection, use case involving pattern-based file line filtering.","code":""},{"path":[]},{"path":"https://smartiing.github.io/seekr/reference/seekr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"seekr: Extract Matching Lines from Matching Files — seekr-package","text":"Maintainer: Sacha Martingay martingay.sacha@hotmail.com [copyright holder]","code":""},{"path":"https://smartiing.github.io/seekr/news/index.html","id":"seekr-011","dir":"Changelog","previous_headings":"","what":"seekr 0.1.1","title":"seekr 0.1.1","text":"Added realistic, minimal files (.R, .csv, .log, .yaml, .json) inst/extdata/ demonstrate package’s usage. files used examples allow seek() seek_in() run without requiring external data.","code":""},{"path":"https://smartiing.github.io/seekr/news/index.html","id":"seekr-010","dir":"Changelog","previous_headings":"","what":"seekr 0.1.0","title":"seekr 0.1.0","text":"Initial CRAN submission.","code":""}]
